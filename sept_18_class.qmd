---
title: "sept_18_class"
format: html
editor: visual
---

## Separate

```{r}
library(tidyr)
table3
```

This table breaks the rule of one cell containing one piece of information

```{r}
table3 |>
  separate(col = rate, into = c("cases", "pop"))
```

What if we wanted to create a new column 'rate' which is cases divided by pop? We can't because "cases" and "pop" are string values.

```{r}
table3 |>
  separate(col = rate, into = c("cases", "pop"), convert = TRUE)
```

Convert is set to false by default. Setting it to true makes it numerical variables. Cannot use to specify beyond text or number variables.

Each separator does not have to be the same. Can be "/", ",", "-"... any non-numerical value.

You can specify that "." represents a decimal point by doing the following:

```{r}
tb <- tibble("v1" = c("a", "b", "c"),
             "v2" = c("12-78.65/6.1", "10-7.4/4.3", "5-7.5/3.1"))
tb |> separate(col = "v2", into = c("a1", "a2"),
               sep = "/ | -")
```

\| is or that indicates "/" or "-"

how to divide by position:

```{r}
tb <- tibble("v1" = c("a", "b", "c"),
             "v2" = c("12-78.65/6.1", "10-7.4/4.3", "5-7.5/3.1"))
tb |> separate(col = "v2", into = c("a1", "a2"),
               sep = 2)
```

To separate by two positions:

```{r}
tb <- tibble("v1" = c("a", "b", "c"),
             "v2" = c("12-78.65/6.1", "10-7.4/4.3", "5-7.5/3.1"))
tb |> separate(col = "v2", into = c("a1", "a2"),
               sep = c(2 , 3))
```

How to count from the last digit

```{r}
tb <- tibble("v1" = c("a", "b", "c"),
             "v2" = c("12-78.65/6.1", "10-7.4/4.3", "5-7.5/3.1"))
tb |> separate(col = "v2", into = c("a1", "a2"),
               sep = -2)
```

## Unite

```{r}
table5
table5 |>
  unite(c("century", "year"), col = "year_new", sep = "-")
```

For no separator, use empty quotes

```{r}
table5
table5 |>
  unite(c("century", "year"), col = "year_new", sep = "")
```

## [Exercise 5](https://javieralvarezliebana.es/docencia/mucss-data-programming/slides/#/tu-turno-1-2)

Take a look at the `billboard` table in the `{tidyr}` package. Is it tidydata? If not, what is wrong, how to convert it to tidy data in case it is not already?

```{r}
billboard
```

```{r}
 billboard |>
  pivot_longer(cols = wk1:wk76,
               names_to = "week",
               values_to = "position",
               names_prefix = "wk",
              values_drop_na = TRUE)
```

names_prefix removes the "wk" from the data

values_drop_na = TRUE removes NA variables

Can pivot in 3 ways:

```{r}
#| eval: false
billboard |>
  pivot_longer(cols = c(wk1, wk2, wk3, wk4, ...))
  pivot_longer(cols = wk1:wk76)
  pivot_longer(cols = -c(artist, track, date.entered))
```

```{r}
relig_income
```

```{r}
relig_income |>
  pivot_longer(cols = -religion,
               names_to = "income_bracket",
               values_to = "count")
```

```{r}
library(tidyverse)
library(tidyr)
library(dplyr)
```

## What can you do with a database?

#### Working with Rows

-   filter rows, drop, arrange / order, sample, remove duplicates, sample

#### Working with Columns

-   select columns, create variables, rename, modify a variable

#### Summarize Actions (new table with statistics)

-   sum, mean, count

#### Join (with other tables)

-   merge

## Working with Rows - Sampling

One of the most common operations is what is known in statistics as **sampling**: a **selection or filtering of records (rows)** (a subsample).

#### **Non-random (by quota)**

based on logical conditions on the records (`filter()`).

-   filter by people who verify that...

-   need to put logical conditions inside the filter()

-   will always return TRUE, FALSE values

Examples:

```{r}
#| eval: false
starwars |>
  filter(mass < 50 & height > 90 & eye_color == "brown")
```

```{r}
#| eval: false
starwars |>
  filter(eye_color == "brown" | eye_color == "green" | eye_color == "blue")
starwars |>
  filter(eye_color %in% c("brown", "green", "blue"))
```

```{r}
#| eval: false
starwars |>
  filter(between(mass, 60, 90))
starwars |>
  filter(mass > 60 & mass < 90)
```

#### **Non-random (intentional/discretionary)**

based on a position (`slice()`).

```{r}
starwars |>
  slice(7)
```

slices row 7

```{r}
starwars |>
  slice( c(7, 10))
```

slices only 7th and 10th row

```{r}
starwars |>
  slice(7:15)
```

slices rows 7-15

#### **Simple random**

(`slice_sample()`).

-   

#### **Stratified**

(`group_by()` + `slice_sample()`).

-   Usually in statistics, we will use stratified. Stratified will sample by proportions that are representative of the population (i.e. 50% male, 50% female).
