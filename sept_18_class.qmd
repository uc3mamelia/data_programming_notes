---
title: "sept_18_class"
format: html
editor: visual
---

## Separate

```{r}
library(tidyr)
table3
```

This table breaks the rule of one cell containing one piece of information

```{r}
table3 |>
  separate(col = rate, into = c("cases", "pop"))
```

What if we wanted to create a new column 'rate' which is cases divided by pop? We can't because "cases" and "pop" are string values.

```{r}
table3 |>
  separate(col = rate, into = c("cases", "pop"), convert = TRUE)
```

Convert is set to false by default. Setting it to true makes it numerical variables. Cannot use to specify beyond text or number variables.

Each separator does not have to be the same. Can be "/", ",", "-"... any non-numerical value.

You can specify that "." represents a decimal point by doing the following:

```{r}
tb <- tibble("v1" = c("a", "b", "c"),
             "v2" = c("12-78.65/6.1", "10-7.4/4.3", "5-7.5/3.1"))
tb |> separate(col = "v2", into = c("a1", "a2"),
               sep = "/ | -")
```

\| is or that indicates "/" or "-"

how to divide by position:

```{r}
tb <- tibble("v1" = c("a", "b", "c"),
             "v2" = c("12-78.65/6.1", "10-7.4/4.3", "5-7.5/3.1"))
tb |> separate(col = "v2", into = c("a1", "a2"),
               sep = 2)
```

To separate by two positions:

```{r}
tb <- tibble("v1" = c("a", "b", "c"),
             "v2" = c("12-78.65/6.1", "10-7.4/4.3", "5-7.5/3.1"))
tb |> separate(col = "v2", into = c("a1", "a2"),
               sep = c(2 , 3))
```

How to count from the last digit

```{r}
tb <- tibble("v1" = c("a", "b", "c"),
             "v2" = c("12-78.65/6.1", "10-7.4/4.3", "5-7.5/3.1"))
tb |> separate(col = "v2", into = c("a1", "a2"),
               sep = -2)
```

## Unite

```{r}
table5
table5 |>
  unite(c("century", "year"), col = "year_new", sep = "-")
```

For no separator, use empty quotes

```{r}
table5
table5 |>
  unite(c("century", "year"), col = "year_new", sep = "")
```

## [Exercise 5](https://javieralvarezliebana.es/docencia/mucss-data-programming/slides/#/tu-turno-1-2)

Take a look at the `billboard` table in the `{tidyr}` package. Is it tidydata? If not, what is wrong, how to convert it to tidy data in case it is not already?

```{r}
billboard
```

```{r}
 billboard |>
  pivot_longer(cols = wk1:wk76,
               names_to = "week",
               values_to = "position",
               names_prefix = "wk",
              values_drop_na = TRUE)
```

names_prefix removes the "wk" from the data

values_drop_na = TRUE removes NA variables

Can pivot in 3 ways:

```{r}
#| eval: false
billboard |>
  pivot_longer(cols = c(wk1, wk2, wk3, wk4, ...))
  pivot_longer(cols = wk1:wk76)
  pivot_longer(cols = -c(artist, track, date.entered))
```

```{r}
relig_income
```

```{r}
relig_income |>
  pivot_longer(cols = -religion,
               names_to = "income_bracket",
               values_to = "count")
```

```{r}
library(tidyverse)
library(tidyr)
library(dplyr)
```

## What can you do with a database?

#### Working with Rows

-   filter rows, drop, arrange / order, sample, remove duplicates, sample

#### Working with Columns

-   select columns, create variables, rename, modify a variable

#### Summarize Actions (new table with statistics)

-   sum, mean, count

#### Join (with other tables)

-   merge

## Working with Rows - Sampling

One of the most common operations is what is known in statistics as **sampling**: a **selection or filtering of records (rows)** (a subsample).

#### **Non-random (by quota)**

based on logical conditions on the records (`filter()`).

-   filter by people who verify that...

-   need to put logical conditions inside the filter()

-   will always return TRUE, FALSE values

Examples:

```{r}
#| eval: false
starwars |>
  filter(mass < 50 & height > 90 & eye_color == "brown")
```

```{r}
#| eval: false
starwars |>
  filter(eye_color == "brown" | eye_color == "green" | eye_color == "blue")
starwars |>
  filter(eye_color %in% c("brown", "green", "blue"))
```

```{r}
#| eval: false
starwars |>
  filter(between(mass, 60, 90))
starwars |>
  filter(mass > 60 & mass < 90)
```

#### **Non-random (intentional/discretionary)**

based on a position (`slice()`).

```{r}
#| eval: false
starwars |>
  slice(7)
```

slices row 7

```{r}
#| eval: false
starwars |>
  slice( c(7, 10))
```

slices only 7th and 10th row

```{r}
#| eval: false
starwars |>
  slice(7:15)
```

slices rows 7-15

```{r}
#| eval: false
starwars |>
  slice_head(n = 4)
```

From 1 to 4

```{r}
#| eval: false
starwars |>
  slice_tail(n = 5)
```

From last row to n + 1. Likely not to use this

```{r}
#| eval: false
starwars |>
  slice_max(mass, n = 5)
```

Returns the five characters with the largest mass.

```{r}
starwars |>
  slice_min(mass, n = 4)
```

returns the four characters with the smallest mass. Notice that R2-D2 and R5-D4 weigh the same, so it returns five characters.

```{r}
starwars |>
  slice_min(mass, n = 4, with_ties = FALSE)
```

With ties removes the tie and returns four characters, but eliminates R5-D4 based on order.

```{r}
starwars |>
  arrange(mass, desc(height)) |>
  slice_head(n = 4)
```

This is a way to put R5-D4 first by ordering by mass, then height and then selecting a slice.

#### **Simple random**

(`slice_sample()`).

-   random is based on the microseconds of your computer. It captures a snapshot based on the microseconds.

```{r}
starwars |>
  slice_sample(n = 3)
```

selects a random 3 rows

```{r}
set.seed(12345)
starwars |>
  slice_sample(n = 3)
```

set.seed breaks the randomness and decides which rows to select.

```{r}
#| eval: false
starwars |>
  slice_sample(n = 90, replace = TRUE)
```

Replacement = TRUE means rows can be repeated.

#### **Stratified**

(`group_by()` + `slice_sample()`).

-   Usually in statistics, we will use stratified. Stratified will sample by proportions that are representative of the population (i.e. 50% male, 50% female).
-   We want to give proportional weight in the sample that matches the weights of the population

```{r}
starwars |>
  drop_na(mass) |>
  slice_sample(n = 2, weight_by = mass)
```

weight_by changes the probability of the individuals comparable to the variable 'mass'. The larger the number, the higher the probability.

```{r}
starwars |>
  drop_na(mass) |>
  slice_sample(n = 2, weight_by = 1/mass)
```

1/variable. The lower the number, the higher the probability. Only works with positive numerical values.
